<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Analizador de Salud de Mercado TCG - CardTrader</title>
    <style>
        :root {
            --bg-color: #121212;
            --surface-color: #1e1e1e;
            --primary-color: #bb86fc;
            --secondary-color: #03dac6;
            --text-color: #e0e0e0;
            --error-color: #cf6679;
            --border-color: #333;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            margin: 0;
            padding: 20px;
            line-height: 1.6;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        h1 { color: var(--primary-color); border-bottom: 1px solid var(--border-color); padding-bottom: 10px; }
        h2 { font-size: 1.2rem; margin-top: 0; }

        /* Panel de Configuraci√≥n */
        .config-panel {
            background-color: var(--surface-color);
            padding: 20px;
            border-radius: 8px;
            border: 1px solid var(--border-color);
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
        }

        .form-group {
            display: flex;
            flex-direction: column;
        }

        label { margin-bottom: 5px; font-weight: bold; font-size: 0.9rem; }
        input[type="text"], input[type="number"], select {
            background-color: #2c2c2c;
            border: 1px solid var(--border-color);
            color: white;
            padding: 10px;
            border-radius: 4px;
        }

        button {
            background-color: var(--primary-color);
            color: #000;
            border: none;
            padding: 12px 24px;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            transition: opacity 0.2s;
            margin-top: 24px; /* Alinear con los inputs */
            width: 100%;
        }

        button:hover { opacity: 0.9; }
        button:disabled { background-color: #555; cursor: not-allowed; }

        /* Logs y Progreso */
        .status-panel {
            background-color: #000;
            padding: 15px;
            border-radius: 4px;
            font-family: 'Courier New', Courier, monospace;
            height: 150px;
            overflow-y: auto;
            margin-bottom: 20px;
            border: 1px solid var(--border-color);
            font-size: 0.85rem;
        }

        .log-entry { margin: 2px 0; }
        .log-info { color: #888; }
        .log-success { color: var(--secondary-color); }
        .log-error { color: var(--error-color); }
        .log-warn { color: #ffb74d; }

        progress {
            width: 100%;
            height: 10px;
            margin-bottom: 10px;
            appearance: none;
        }
        progress::-webkit-progress-bar { background-color: #333; border-radius: 5px; }
        progress::-webkit-progress-value { background-color: var(--secondary-color); border-radius: 5px; }

        /* Tabla de Resultados */
        table {
            width: 100%;
            border-collapse: collapse;
            background-color: var(--surface-color);
            border-radius: 8px;
            overflow: hidden;
        }

        th, td {
            padding: 12px 15px;
            text-align: left;
            border-bottom: 1px solid var(--border-color);
        }

        th { 
            background-color: #252525; 
            color: var(--primary-color); 
            cursor: pointer; /* Indicador visual de que se puede ordenar */
            user-select: none;
        }
        
        th:hover { background-color: #333; }

        tr:hover { background-color: #2a2a2a; }
        
        .metric-main { display: block; font-size: 1.1em; font-weight: bold; }
        .metric-sub { display: block; font-size: 0.8em; color: #888; }
        
        .high-supply { color: var(--secondary-color); }
        .low-supply { color: var(--error-color); }

        .hidden { display: none; }
    </style>
</head>
<body>

<div class="container">
    <h1>üìä Analizador de Salud de Mercado TCG</h1>
    
    <div class="config-panel">
        <div class="form-group">
            <label for="apiToken">API Token (CardTrader)</label>
            <input type="password" id="apiToken" placeholder="Pega tu token aqu√≠...">
            <small style="color: #777; margin-top:5px;">El token se guarda localmente en tu navegador.</small>
        </div>

        <div class="form-group">
            <label for="nthExpansion">Rango de Sets (Recientes)</label>
            <input type="number" id="nthExpansion" value="3" min="1">
            <small style="color: #777; margin-top:5px;">Analizar los X √∫ltimos sets (evitar solo el √∫ltimo).</small>
        </div>

        <div class="form-group">
            <label for="minCards">M√≠nimo de Cartas (Filtro)</label>
            <input type="number" id="minCards" value="120" min="10">
            <small style="color: #777; margin-top:5px;">Ignorar sets con menos de X cartas (evita promos/demos).</small>
        </div>

        <div class="form-group">
            <button id="btnAnalyze" onclick="startAnalysis()">Iniciar An√°lisis</button>
        </div>
    </div>

    <progress id="progressBar" value="0" max="100"></progress>
    <div id="logContainer" class="status-panel">
        <div class="log-entry log-info">> Esperando inicio...</div>
    </div>

    <table id="resultsTable">
        <thead>
            <tr>
                <th onclick="sortTable(0)">Juego ‚Üï</th>
                <th onclick="sortTable(1)">Expansi√≥n Analizada ‚Üï</th>
                <th onclick="sortTable(2)" title="Click para ordenar">Oferta Total (Promedio) ‚Üï</th>
                <th onclick="sortTable(3)">Estado ‚Üï</th>
            </tr>
        </thead>
        <tbody>
            </tbody>
    </table>
</div>

<script>
    // Configuraci√≥n base
    const BASE_URL = 'https://api.cardtrader.com/api/v2';
    
    // Referencias DOM
    const els = {
        token: document.getElementById('apiToken'),
        nth: document.getElementById('nthExpansion'),
        minCards: document.getElementById('minCards'),
        btn: document.getElementById('btnAnalyze'),
        logs: document.getElementById('logContainer'),
        progress: document.getElementById('progressBar'),
        table: document.getElementById('resultsTable'),
        tableBody: document.querySelector('#resultsTable tbody')
    };

    // Cargar token guardado
    window.onload = () => {
        const savedToken = localStorage.getItem('ct_api_token');
        if (savedToken) els.token.value = savedToken;
    };

    // Utilidades de Logging
    function log(msg, type = 'info') {
        const div = document.createElement('div');
        div.className = `log-entry log-${type}`;
        div.textContent = `> ${msg}`;
        els.logs.appendChild(div);
        els.logs.scrollTop = els.logs.scrollHeight;
    }

    const sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));

    // Wrapper seguro para Fetch (SIN PROXY)
    async function fetchAPI(endpoint, token) {
        const url = BASE_URL + endpoint;
        
        try {
            const response = await fetch(url, {
                method: 'GET',
                headers: {
                    'Authorization': `Bearer ${token}`, 
                    'Accept': 'application/json'
                }
            });

            if (response.status === 429) {
                log("Rate Limit alcanzado. Esperando 5 segundos...", "warn");
                await sleep(5000);
                return fetchAPI(endpoint, token); // Retry
            }

            if (!response.ok) {
                const errText = await response.text();
                throw new Error(`Error ${response.status}: ${errText}`);
            }

            return await response.json();
        } catch (error) {
            throw error;
        }
    }

    // L√≥gica Principal
    async function startAnalysis() {
        const token = els.token.value.trim();
        const nRule = parseInt(els.nth.value) || 3;
        const minCardsRule = parseInt(els.minCards.value) || 100;

        if (!token) return log("Error: Debes introducir un API Token.", "error");
        
        localStorage.setItem('ct_api_token', token);
        els.btn.disabled = true;
        els.tableBody.innerHTML = '';
        els.logs.innerHTML = '';
        els.progress.value = 0;
        
        log("Iniciando an√°lisis...", "info");

        try {
            log("Obteniendo lista de juegos...", "info");
            const gamesResponse = await fetchAPI('/games', token);
            const games = gamesResponse.array || gamesResponse; 
            
            if (!Array.isArray(games)) throw new Error("La respuesta de /games no es una lista v√°lida.");

            log(`Se encontraron ${games.length} juegos.`, "success");

            log("Descargando base de datos de expansiones...", "info");
            const allExpansions = await fetchAPI('/expansions', token);
            log(`Descargadas ${allExpansions.length} expansiones. Procesando...`, "success");

            const expansionsByGame = {};
            allExpansions.forEach(exp => {
                if (!expansionsByGame[exp.game_id]) expansionsByGame[exp.game_id] = [];
                expansionsByGame[exp.game_id].push(exp);
            });

            // --- BUCLE DE AN√ÅLISIS ---
            let processedCount = 0;
            const totalToProcess = games.length;

            for (const game of games) {
                processedCount++;
                els.progress.value = (processedCount / totalToProcess) * 100;

                const gameExpansions = expansionsByGame[game.id] || [];
                
                if (gameExpansions.length === 0) continue;

                // Ordenar: m√°s nuevo primero
                gameExpansions.sort((a, b) => b.id - a.id);

                // Cogemos m√°s candidatos de los necesarios por si filtramos muchos sets peque√±os
                const searchDepth = nRule + 3; 
                const candidates = gameExpansions.slice(0, searchDepth);
                
                log(`Analizando ${game.name}...`, "info");

                let bestExpansion = null;
                let maxAverageSupply = -1;

                // Iteramos candidatos hasta encontrar el mejor que cumpla las normas
                let checkedCount = 0;

                for (const exp of candidates) {
                    // Respetamos la regla de "Mirar solo los X √∫ltimos". 
                    // Si ya hemos mirado los N indicados, paramos.
                    if (checkedCount >= nRule) break;
                    
                    try {
                        await sleep(250); 
                        const productsMap = await fetchAPI(`/marketplace/products?expansion_id=${exp.id}`, token);
                        
                        let currentSupply = 0;
                        let uniqueBlueprints = 0;

                        // Contar stock y cartas √∫nicas
                        Object.values(productsMap).forEach(productList => {
                            if (productList.length > 0) uniqueBlueprints++; // Solo cuenta si tiene alg√∫n producto listado
                            productList.forEach(product => {
                                currentSupply += (product.quantity || 0);
                            });
                        });

                        // --- FILTRO DE M√çNIMO DE CARTAS ---
                        if (uniqueBlueprints < minCardsRule) {
                            log(`Skipping ${exp.name} (ID: ${exp.id}): Solo tiene ${uniqueBlueprints} cartas (Min: ${minCardsRule})`, "warn");
                            continue; // Saltamos este set y pasamos al siguiente candidato
                        }

                        // Si pasa el filtro, cuenta como una de las "N" expansiones revisadas
                        checkedCount++;

                        const avgSupply = uniqueBlueprints > 0 ? (currentSupply / uniqueBlueprints) : 0;
                        log(`Set V√°lido: ${exp.name} - Avg: ${avgSupply.toFixed(2)}`, "info");

                        if (avgSupply > maxAverageSupply) {
                            maxAverageSupply = avgSupply;
                            bestExpansion = {
                                name: exp.name,
                                supply: currentSupply,
                                unique: uniqueBlueprints,
                                average: avgSupply
                            };
                        }

                    } catch (err) {
                        log(`Error leyendo expansi√≥n ${exp.id}: ${err.message}`, "error");
                    }
                }

                if (bestExpansion) {
                    addTableRow(game.name, bestExpansion.name, bestExpansion.supply, bestExpansion.unique, bestExpansion.average);
                } else {
                    addTableRow(game.name, `Sin sets v√°lidos (> ${minCardsRule} cartas)`, 0, 0, 0, false, true);
                }
            }
            
            log("An√°lisis completado.", "success");
            
            // Ordenar tabla autom√°ticamente al finalizar
            sortTable(2); 

        } catch (error) {
            log(`Error Cr√≠tico: ${error.message}`, "error");
        } finally {          
            els.btn.disabled = false;
        }
    }    

    function addTableRow(gameName, expansionName, supply, blueprintsCount, average, isError
